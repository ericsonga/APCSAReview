.. qnum::
   :prefix: 14-4-
   :start: 1
   
Practice Exam 6 for the AP CS A Exam
-------------------------------------

The following problems are similar to what you might see on the AP CS A exam.  Please answer each to the best of your ability.  Click the "Start" button when you are ready to begin the exam, but only then as you can only take the exam once.  Click the "Pause" button to pause the exam (you will not be able to see the questions when the exam is paused).  Click on the "Finish Exam" button only when you are done.  It will display the number correct, number wrong, and number skipped after the "Finish Exam" button.

.. timed:: postexam6
    :timelimit: 45
    
    .. mchoice:: pe6_1
       :answer_a: 2
       :answer_b: 0
       :answer_c: -2
       :answer_d: 4
       :answer_e: -4
       :correct: c
       :feedback_a:  This method generates a sequence. The call mystery(1) will return 2 and mystery(2) returns 4. Then each subsequent number is generated by subtracting the previous two terms. So we have a sequence tha looks like this.. 2, 4, 2, -2, -4, -2.   
       :feedback_b:  This number will never be generated by this method. 
       :feedback_c:  The sequence that this method generates will look like this: 2, 4, 2, -2, -4, -2 with 2 returned when n is 1 and -2 returned when n is 6. 
       :feedback_d:  This would be returned if we called mystery(2).
       :feedback_e:  This would be returned when we call mystery(5).

       Refer to the code below. What will be returned by the call mystery(6)?
       
       .. code-block:: java

         public int mystery(int n) 
         {
            if (n == 1 || n == 2) 
            {
               return 2 * n;
            } else 
            {
               return mystery(n - 1) - mystery(n - 2);
            }
         }

    .. mchoice:: pe6_2
       :answer_a: I
       :answer_b: II
       :answer_c: III
       :answer_d: I, II
       :answer_e: I, II and III
       :correct: e
       :feedback_a: This is correct since it simply invokes the constructor of its super class. But, this is not the only correct implementation. 
       :feedback_b: This implementation starts by initializing balance to 0 by invoking the default constructor of its super class. Then it calls the inherited deposit method to add acctBalance to the account. But, this is not the only correct implementation. 
       :feedback_c: Here super is automatically called as the first line of the constructor code even if there is not an explicit call to super in the code. But, this is not the only correct implementation. 
       :feedback_d: Both of these implementations are valid, but they aren't the only valid implementations.
       :feedback_e: Choice I simply invokes the parent class constructor. Choice II starts by initializing balance to 0 by invoking the default constructor of the parent class. Then it calls the inherited deposit method to add acctBalance to the account. For Choice III super is automatically called as the first line of the constructor code if there is not an explicit call to super, so this the same as choice II. 

       Refer to the code below. Which of these are correct implementations of the CheckingAccount constructor?
       
       .. code-block:: java

         public class BankAccount { 
            private double balance;

            public BankAccount() {
               balance = 0;
            }

            public BankAccount(double acctBalance) {
               balance = acctBalance;
            }

            public void deposit(double amount) {
               balance += amount;
            }

            public void withdraw(double amount) {
               balance -= amount;
            }

            public double getBalance() {
               return balance;
            }
         }

         public class CheckingAccount extends BankAccount {
            private static final double FEE = 2.0;
            private static final double MIN_BALANCE = 50.0;

            public CheckingAccount(double acctBalance) {
               /* implementation not shown */
            }

            public void withdraw(double amount) {
               /* implementation not shown */
            }
         }

          I. super(acctBalance);
          II. super();
              deposit(acctBalance);
          III. deposit(acctBalance);


    .. mchoice:: pe6_3
       :answer_a: I
       :answer_b: II
       :answer_c: III
       :answer_d: IV
       :answer_e: V
       :correct: d
       :feedback_a:  Static (class) variables can be initialized inside a constructor. 
       :feedback_b:  Static (class) variables may also be final variables, but don't have to be final.
       :feedback_c:  Any instance variable can be declared final. This just means that its value will never change.
       :feedback_d:  A static method is a method that is on a class, not on an object. Therefore it does not have access to any instance variables from any object.  
       :feedback_e:  Class and object methods can both access a static variable. 

       Which of the following statements is true? 
       
       .. code-block:: java

         I. A static variable cannot be initialized in a constructor
         II. A static variable must be declared final
         III. An instance variable can't be declared final
         IV. A static method doesn't have access to instance variables
         V. Only a static method can access a static variable
         
    .. mchoice:: pe6_4
       :answer_a: number / i == 0
       :answer_b: i % number == 0 
       :answer_c: number % i != 0
       :answer_d: number % i == 0
       :answer_e: i / number == 0
       :correct: d
       :feedback_a: This is checking if number divided by i returns 0 which will be true whenever number is less than i (remember that the fractional part is thrown away with integer division). In this case i is less than or equal to number so this will never be true. 
       :feedback_b: This is checking if number divides into i evenly instead of if i divides into number evenly.  
       :feedback_c: This is true when i does not divide evenly into number.  
       :feedback_d: When the remainder from dividing number by i is 0 then it can be said that i divides evenly into number.  
       :feedback_e: This is checking if i divided by number returns 0 (remember that the fractional part is thrown away with integer division).  Since i starts out at 1 it will always be true until i equals number.

       Which of the following can be used to replace /* condition */ in the code below so that the method returns the number of integers that divide evenly into the given number?
       
       .. code-block:: java

         public static int countEvenDivs(int number)
         {
            int count = 0;
            for (int i = 1; i <= number; i++) 
            {
               if (/* condition */)
               {
                  count = count + 1;
               }
            }
            return count;
         }